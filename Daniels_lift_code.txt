'General note: floors are numbered ascending, so the bottom floor is floor 1.
'Components are numbered accordingly, i.e LED1 is the LED on the bottom floor.

'These assign output pins and variables in the chip memory to text strings for easy identification
symbol LED3 = B.7    'LED's for each floor.
symbol LED2 = B.6    '"high" to turn on, "low" to turn off.
symbol LED1 = B.5    '___

symbol SR1a = pinC.3 'Microswitches on each floor.
symbol SR1b = pinC.2 '"a" switches are below the door, "b" switches are above.
symbol SR2a = pinC.1 'Switches are positioned so that when both are pressed by the lift car,
symbol SR2b = pinC.0 'the car is lined up with the door.
symbol SR3b = pinB.1 '
symbol SR3a = pinB.0 '___

symbol BTN1 = pinA.2 'Buttons that users can press to control the lift
symbol BTN2 = pinA.3 'note that these are PUSH TO BREAK, so when the button is pressed the input is 0 and when it is not pressed the input is 1
symbol BTN3 = pinA.1 '___

'symbol DR1 = C.4    'Controls for the doors, not implemented in the current design.
'symbol DR2 = C.5    'These have been kept because the circuit components to control them are still present.
'symbol DR3 = C.6    '___

symbol VRBL = A.0    'Input from the variable resistor. use readADC command to get a value between 0 and 255.
symbol BTNM = pinC.7 'Fourth button, situated near top of design and not associated with any floor. Used for mode switch.
symbol SND = B.4     'Output to on-board piezo sounder. use "sound" command. see examples or manual for more detailed info.
symbol MTRU = B.3    'output on this pin to make the lift car go up. can be pulsed to vary speed
symbol MTRD = B.2    'likewise to make the lift go down. note that if both pins are set to high the lift will do nothing.

symbol liftPos = b0  'What floor the lift is at (1-3, value of 0 indicates no match)
symbol VRBLread = b1 'raw data from the variable reistor (0-255)
symbol mode = b2     'what control mode the lift is currently in

'These variables are used in manual control. note that they do not use the same scale as the basic liftPos.
'symbol sLiftPos = b5    'What position the lift is meant to be at (setLiftPos)
'symbol tLiftPos = b6    'What position the lift is estimated to be at (theoreticalLiftPos)
'symbol aLiftPosMin = b7 'The lowest the lift can be (actualLiftPosMin)
'symbol aLiftPosMax = b8 'The highest the lift can be (actualLiftPosMax)
'symbol rLiftPos = b9    '

'The main code that controls the lift

main:

'Subroutines

posCheck:
write liftpos,0
if SR1a = 1 and SR1b = 1 then write liftPos,1
elseif SR2a = 1 and SR2b = 1 then write liftPos,2
elseif SR3a = 1 and SR3b = 1 then write liftPos,3
endif
return

liftAlign1:
if SR1a = 1 and SR1b = 0 then
high MTRU
pause 1
low MTRU
goto liftAlign1
elseif SR1a = 0 and SR1b = 1 then
high MTRD
pause 1
low MTRD
goto liftAlign1
else
low MTRU,MTRD
gosub posCheck
return
endif

liftAlign2:
if SR2a = 1 and SR2b = 0 then
high MTRU
pause 1
low MTRU
goto liftAlign2
elseif SR2a = 0 and SR2b = 1 then
high MTRD
pause 1
low MTRD
goto liftAlign2
else
low MTRU,MTRD
gosub posCheck
return
endif

liftAlign3:
if SR3a = 3 and SR3b = 0 then
high MTRU
pause 1
low MTRU
goto liftAlign3
elseif SR3a = 0 and SR3b = 3 then
high MTRD
pause 1
low MTRD
goto liftAlign3
else
low MTRU,MTRD
gosub posCheck
return
endif